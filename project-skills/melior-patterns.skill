# Melior Plus Patterns Skill

> Project-specific patterns for Melior Plus MVP development.

---

## Project Overview

**Melior Plus** - Internal project management tool for electrical engineering company.

### Tech Stack
- **Frontend:** Vue.js → React (migration in progress)
- **Backend:** Node.js + Express
- **Database:** Supabase (PostgreSQL)
- **Language:** TypeScript throughout
- **State:** Pinia (Vue) → Zustand (React)

---

## API Response Format

### Standard Response Structure
```typescript
// Success response
{
  "success": true,
  "data": { /* response data */ },
  "meta": {
    "timestamp": "2025-11-25T10:30:00Z",
    "requestId": "req_abc123"
  }
}

// Error response
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Email is required",
    "details": [
      { "field": "email", "message": "Required field" }
    ]
  },
  "meta": {
    "timestamp": "2025-11-25T10:30:00Z",
    "requestId": "req_abc123"
  }
}
```

### Response Helper (Backend)
```typescript
// lib/response.ts
export function successResponse<T>(data: T, meta?: Record<string, any>) {
  return {
    success: true,
    data,
    meta: {
      timestamp: new Date().toISOString(),
      ...meta
    }
  }
}

export function errorResponse(
  code: string,
  message: string,
  details?: any[]
) {
  return {
    success: false,
    error: { code, message, details },
    meta: { timestamp: new Date().toISOString() }
  }
}
```

---

## Authentication Pattern

### Token Structure
```typescript
// Auth tokens managed on backend only
interface AuthTokens {
  accessToken: string    // Short-lived (15 min)
  refreshToken: string   // Long-lived (7 days)
}

// User session
interface Session {
  user: {
    id: string
    email: string
    role: 'admin' | 'manager' | 'user'
    teamId: string
  }
  expiresAt: number
}
```

### Auth Middleware
```typescript
// middleware/auth.ts
import { supabase } from '@/lib/supabase'

export async function authMiddleware(req: Request, res: Response, next: NextFunction) {
  const authHeader = req.headers.authorization

  // Case-insensitive Bearer check
  if (!authHeader?.toLowerCase().startsWith('bearer ')) {
    return res.status(401).json(errorResponse('UNAUTHORIZED', 'Missing authorization'))
  }

  const token = authHeader.slice(7) // Remove 'Bearer '

  try {
    const { data: { user }, error } = await supabase.auth.getUser(token)

    if (error || !user) {
      return res.status(401).json(errorResponse('UNAUTHORIZED', 'Invalid token'))
    }

    req.user = user
    next()
  } catch (err) {
    return res.status(401).json(errorResponse('UNAUTHORIZED', 'Token verification failed'))
  }
}
```

---

## Database Patterns

### Core Tables
```sql
-- Users (extends Supabase auth.users)
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id),
  email TEXT NOT NULL,
  full_name TEXT,
  role TEXT DEFAULT 'user' CHECK (role IN ('admin', 'manager', 'user')),
  team_id UUID REFERENCES teams(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Projects
CREATE TABLE projects (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  code TEXT UNIQUE NOT NULL,           -- e.g., "EP-2025-001"
  name TEXT NOT NULL,
  client_name TEXT,
  status TEXT DEFAULT 'draft' CHECK (status IN ('draft', 'active', 'completed', 'archived')),
  priority TEXT DEFAULT 'normal' CHECK (priority IN ('low', 'normal', 'high', 'urgent')),
  deadline DATE,
  owner_id UUID REFERENCES profiles(id),
  team_id UUID REFERENCES teams(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tasks
CREATE TABLE tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT,
  status TEXT DEFAULT 'todo' CHECK (status IN ('todo', 'in_progress', 'review', 'done')),
  priority TEXT DEFAULT 'normal',
  assignee_id UUID REFERENCES profiles(id),
  due_date DATE,
  estimated_hours DECIMAL(5,2),
  actual_hours DECIMAL(5,2),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

### RLS Policies Pattern
```sql
-- Team-based access
CREATE POLICY "Users see team projects"
  ON projects FOR SELECT
  USING (
    team_id IN (
      SELECT team_id FROM profiles WHERE id = auth.uid()
    )
  );

-- Admin override
CREATE POLICY "Admins see all projects"
  ON projects FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE id = auth.uid() AND role = 'admin'
    )
  );
```

---

## Frontend Patterns (React)

### Component Structure
```
src/
├── components/
│   ├── ui/                 # Base components
│   │   ├── Button.tsx
│   │   ├── Input.tsx
│   │   ├── Modal.tsx
│   │   └── index.ts
│   ├── projects/           # Feature components
│   │   ├── ProjectCard.tsx
│   │   ├── ProjectList.tsx
│   │   └── ProjectForm.tsx
│   └── layout/             # Layout components
│       ├── Sidebar.tsx
│       ├── Header.tsx
│       └── MainLayout.tsx
├── hooks/                  # Custom hooks
│   ├── useProjects.ts
│   ├── useTasks.ts
│   └── useAuth.ts
├── stores/                 # Zustand stores
│   ├── projectStore.ts
│   └── authStore.ts
├── services/               # API services
│   ├── projectService.ts
│   └── taskService.ts
├── types/                  # TypeScript types
│   ├── project.ts
│   └── task.ts
└── pages/                  # Route pages
    ├── Dashboard.tsx
    ├── Projects.tsx
    └── Settings.tsx
```

### API Service Pattern
```typescript
// services/projectService.ts
import { supabase } from '@/lib/supabase'
import type { Project, ProjectCreate, ProjectUpdate } from '@/types'

export const projectService = {
  async getAll(): Promise<Project[]> {
    const { data, error } = await supabase
      .from('projects')
      .select('*, owner:profiles(*), tasks(count)')
      .order('created_at', { ascending: false })

    if (error) throw error
    return data
  },

  async getById(id: string): Promise<Project> {
    const { data, error } = await supabase
      .from('projects')
      .select('*, owner:profiles(*), tasks(*)')
      .eq('id', id)
      .single()

    if (error) throw error
    return data
  },

  async create(project: ProjectCreate): Promise<Project> {
    const { data, error } = await supabase
      .from('projects')
      .insert(project)
      .select()
      .single()

    if (error) throw error
    return data
  },

  async update(id: string, updates: ProjectUpdate): Promise<Project> {
    const { data, error } = await supabase
      .from('projects')
      .update(updates)
      .eq('id', id)
      .select()
      .single()

    if (error) throw error
    return data
  },

  async delete(id: string): Promise<void> {
    const { error } = await supabase
      .from('projects')
      .delete()
      .eq('id', id)

    if (error) throw error
  }
}
```

### Zustand Store Pattern
```typescript
// stores/projectStore.ts
import { create } from 'zustand'
import { projectService } from '@/services/projectService'
import type { Project } from '@/types'

interface ProjectState {
  projects: Project[]
  currentProject: Project | null
  isLoading: boolean
  error: string | null

  // Actions
  fetchProjects: () => Promise<void>
  fetchProject: (id: string) => Promise<void>
  createProject: (data: ProjectCreate) => Promise<Project>
  updateProject: (id: string, data: ProjectUpdate) => Promise<void>
  deleteProject: (id: string) => Promise<void>
  setCurrentProject: (project: Project | null) => void
}

export const useProjectStore = create<ProjectState>((set, get) => ({
  projects: [],
  currentProject: null,
  isLoading: false,
  error: null,

  fetchProjects: async () => {
    set({ isLoading: true, error: null })
    try {
      const projects = await projectService.getAll()
      set({ projects, isLoading: false })
    } catch (err) {
      set({ error: err.message, isLoading: false })
    }
  },

  fetchProject: async (id: string) => {
    set({ isLoading: true, error: null })
    try {
      const project = await projectService.getById(id)
      set({ currentProject: project, isLoading: false })
    } catch (err) {
      set({ error: err.message, isLoading: false })
    }
  },

  createProject: async (data) => {
    const project = await projectService.create(data)
    set(state => ({ projects: [project, ...state.projects] }))
    return project
  },

  updateProject: async (id, data) => {
    const updated = await projectService.update(id, data)
    set(state => ({
      projects: state.projects.map(p => p.id === id ? updated : p),
      currentProject: state.currentProject?.id === id ? updated : state.currentProject
    }))
  },

  deleteProject: async (id) => {
    await projectService.delete(id)
    set(state => ({
      projects: state.projects.filter(p => p.id !== id),
      currentProject: state.currentProject?.id === id ? null : state.currentProject
    }))
  },

  setCurrentProject: (project) => set({ currentProject: project })
}))
```

---

## Backend Patterns

### Route Structure
```typescript
// routes/projects.ts
import { Router } from 'express'
import { projectController } from '@/controllers/projectController'
import { authMiddleware } from '@/middleware/auth'
import { validateBody } from '@/middleware/validate'
import { createProjectSchema, updateProjectSchema } from '@/schemas/project'

const router = Router()

router.use(authMiddleware)

router.get('/', projectController.getAll)
router.get('/:id', projectController.getById)
router.post('/', validateBody(createProjectSchema), projectController.create)
router.put('/:id', validateBody(updateProjectSchema), projectController.update)
router.delete('/:id', projectController.delete)

export default router
```

### Controller Pattern
```typescript
// controllers/projectController.ts
import { Request, Response } from 'express'
import { projectService } from '@/services/projectService'
import { successResponse, errorResponse } from '@/lib/response'

export const projectController = {
  async getAll(req: Request, res: Response) {
    try {
      const projects = await projectService.getAll(req.user.id)
      res.json(successResponse(projects))
    } catch (err) {
      res.status(500).json(errorResponse('SERVER_ERROR', err.message))
    }
  },

  async getById(req: Request, res: Response) {
    try {
      const project = await projectService.getById(req.params.id)
      if (!project) {
        return res.status(404).json(errorResponse('NOT_FOUND', 'Project not found'))
      }
      res.json(successResponse(project))
    } catch (err) {
      res.status(500).json(errorResponse('SERVER_ERROR', err.message))
    }
  },

  async create(req: Request, res: Response) {
    try {
      const project = await projectService.create({
        ...req.body,
        owner_id: req.user.id
      })
      res.status(201).json(successResponse(project))
    } catch (err) {
      res.status(500).json(errorResponse('SERVER_ERROR', err.message))
    }
  },

  async update(req: Request, res: Response) {
    try {
      const project = await projectService.update(req.params.id, req.body)
      res.json(successResponse(project))
    } catch (err) {
      res.status(500).json(errorResponse('SERVER_ERROR', err.message))
    }
  },

  async delete(req: Request, res: Response) {
    try {
      await projectService.delete(req.params.id)
      res.json(successResponse({ deleted: true }))
    } catch (err) {
      res.status(500).json(errorResponse('SERVER_ERROR', err.message))
    }
  }
}
```

---

## Validation Schemas

```typescript
// schemas/project.ts
import { z } from 'zod'

export const createProjectSchema = z.object({
  name: z.string().min(1, 'Name is required').max(200),
  code: z.string().regex(/^[A-Z]{2,3}-\d{4}-\d{3}$/, 'Invalid project code format'),
  client_name: z.string().optional(),
  status: z.enum(['draft', 'active', 'completed', 'archived']).default('draft'),
  priority: z.enum(['low', 'normal', 'high', 'urgent']).default('normal'),
  deadline: z.string().datetime().optional(),
  team_id: z.string().uuid().optional()
})

export const updateProjectSchema = createProjectSchema.partial()

export type ProjectCreate = z.infer<typeof createProjectSchema>
export type ProjectUpdate = z.infer<typeof updateProjectSchema>
```

---

## Error Codes

```typescript
// lib/errorCodes.ts
export const ErrorCodes = {
  // Auth errors
  UNAUTHORIZED: 'UNAUTHORIZED',
  FORBIDDEN: 'FORBIDDEN',
  TOKEN_EXPIRED: 'TOKEN_EXPIRED',

  // Validation errors
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  INVALID_INPUT: 'INVALID_INPUT',

  // Resource errors
  NOT_FOUND: 'NOT_FOUND',
  ALREADY_EXISTS: 'ALREADY_EXISTS',
  CONFLICT: 'CONFLICT',

  // Server errors
  SERVER_ERROR: 'SERVER_ERROR',
  DATABASE_ERROR: 'DATABASE_ERROR',
  EXTERNAL_SERVICE_ERROR: 'EXTERNAL_SERVICE_ERROR'
} as const
```

---

## TypeScript Types

```typescript
// types/project.ts
export interface Project {
  id: string
  code: string
  name: string
  client_name: string | null
  status: 'draft' | 'active' | 'completed' | 'archived'
  priority: 'low' | 'normal' | 'high' | 'urgent'
  deadline: string | null
  owner_id: string
  team_id: string | null
  created_at: string
  updated_at: string

  // Relations (when joined)
  owner?: Profile
  tasks?: Task[]
}

export type ProjectCreate = Omit<Project, 'id' | 'created_at' | 'updated_at' | 'owner' | 'tasks'>
export type ProjectUpdate = Partial<ProjectCreate>

// types/task.ts
export interface Task {
  id: string
  project_id: string
  title: string
  description: string | null
  status: 'todo' | 'in_progress' | 'review' | 'done'
  priority: 'low' | 'normal' | 'high' | 'urgent'
  assignee_id: string | null
  due_date: string | null
  estimated_hours: number | null
  actual_hours: number | null
  created_at: string
  updated_at: string

  // Relations
  project?: Project
  assignee?: Profile
}
```

---

## Testing Patterns

### API Test Example
```typescript
// tests/api/projects.test.ts
import { describe, test, expect, beforeAll, afterAll } from 'vitest'
import request from 'supertest'
import app from '@/app'
import { createTestUser, cleanupTestData } from '@/tests/helpers'

describe('Projects API', () => {
  let authToken: string
  let testUserId: string

  beforeAll(async () => {
    const { token, userId } = await createTestUser()
    authToken = token
    testUserId = userId
  })

  afterAll(async () => {
    await cleanupTestData(testUserId)
  })

  test('GET /api/projects returns 401 without auth', async () => {
    const res = await request(app).get('/api/projects')
    expect(res.status).toBe(401)
    expect(res.body.success).toBe(false)
  })

  test('GET /api/projects returns projects for authenticated user', async () => {
    const res = await request(app)
      .get('/api/projects')
      .set('Authorization', `Bearer ${authToken}`)

    expect(res.status).toBe(200)
    expect(res.body.success).toBe(true)
    expect(Array.isArray(res.body.data)).toBe(true)
  })

  test('POST /api/projects creates project', async () => {
    const projectData = {
      name: 'Test Project',
      code: 'EP-2025-001',
      status: 'draft'
    }

    const res = await request(app)
      .post('/api/projects')
      .set('Authorization', `Bearer ${authToken}`)
      .send(projectData)

    expect(res.status).toBe(201)
    expect(res.body.data.name).toBe(projectData.name)
  })
})
```

---

## Naming Conventions

### Files
- Components: `PascalCase.tsx` (e.g., `ProjectCard.tsx`)
- Hooks: `camelCase.ts` (e.g., `useProjects.ts`)
- Services: `camelCase.ts` (e.g., `projectService.ts`)
- Types: `camelCase.ts` (e.g., `project.ts`)

### Code
- Variables/Functions: `camelCase`
- Types/Interfaces: `PascalCase`
- Constants: `UPPER_SNAKE_CASE`
- Database columns: `snake_case`

### API Routes
- REST: `/api/projects`, `/api/projects/:id/tasks`
- Actions: `/api/projects/:id/archive` (POST)

---

## Avoid

- Mixing Estonian and English in code (use English only)
- HTML responses from API (JSON only)
- Duplicate utility functions across files
- Hardcoded strings (use constants/i18n)
- Direct database queries in controllers (use services)
- Any type in TypeScript
