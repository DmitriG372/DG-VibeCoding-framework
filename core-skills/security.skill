# Security Skill

> Web application security patterns and best practices.

---

## Input Validation

### Server-Side Validation (Always!)
```typescript
import { z } from 'zod'

// Define schema
const UserSchema = z.object({
  email: z.string().email().max(255),
  password: z.string().min(8).max(100),
  name: z.string().min(1).max(100).regex(/^[a-zA-Z\s]+$/),
  age: z.number().int().min(0).max(150).optional(),
})

// Validate input
function createUser(input: unknown) {
  const result = UserSchema.safeParse(input)
  
  if (!result.success) {
    throw new ValidationError(result.error.issues)
  }
  
  return result.data // Typed and validated
}
```

### Sanitize User Input
```typescript
import DOMPurify from 'dompurify'

// HTML content
const cleanHtml = DOMPurify.sanitize(userInput)

// Plain text (strip all HTML)
const plainText = DOMPurify.sanitize(userInput, { ALLOWED_TAGS: [] })

// Allow specific tags
const limitedHtml = DOMPurify.sanitize(userInput, {
  ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a'],
  ALLOWED_ATTR: ['href']
})
```

### File Upload Validation
```typescript
const ALLOWED_TYPES = ['image/jpeg', 'image/png', 'image/webp']
const MAX_SIZE = 5 * 1024 * 1024 // 5MB

function validateFile(file: File) {
  // Check MIME type
  if (!ALLOWED_TYPES.includes(file.type)) {
    throw new Error('Invalid file type')
  }
  
  // Check size
  if (file.size > MAX_SIZE) {
    throw new Error('File too large')
  }
  
  // Check extension matches type
  const ext = file.name.split('.').pop()?.toLowerCase()
  const validExtensions = { 'image/jpeg': ['jpg', 'jpeg'], 'image/png': ['png'], 'image/webp': ['webp'] }
  
  if (!validExtensions[file.type]?.includes(ext!)) {
    throw new Error('Extension mismatch')
  }
  
  return true
}
```

---

## XSS Prevention

### Never Trust User Input
```typescript
// ❌ Dangerous - XSS vulnerability
element.innerHTML = userInput

// ✅ Safe - escapes HTML
element.textContent = userInput

// ✅ Safe - with sanitization
element.innerHTML = DOMPurify.sanitize(userInput)
```

### Vue Template Safety
```vue
<!-- ✅ Safe - auto-escaped -->
<p>{{ userInput }}</p>

<!-- ❌ Dangerous - renders raw HTML -->
<p v-html="userInput"></p>

<!-- ✅ Safe - sanitized HTML -->
<p v-html="sanitizedInput"></p>

<script setup>
import DOMPurify from 'dompurify'
const sanitizedInput = computed(() => DOMPurify.sanitize(userInput.value))
</script>
```

### URL Handling
```typescript
// ❌ Dangerous - javascript: protocol
const url = userInput
window.location.href = url

// ✅ Safe - validate URL
function isValidUrl(input: string): boolean {
  try {
    const url = new URL(input)
    return ['http:', 'https:'].includes(url.protocol)
  } catch {
    return false
  }
}

if (isValidUrl(userInput)) {
  window.location.href = userInput
}
```

---

## SQL Injection Prevention

### Always Use Parameterized Queries
```typescript
// ❌ Dangerous - SQL injection
const query = `SELECT * FROM users WHERE email = '${email}'`

// ✅ Safe - parameterized (Supabase)
const { data } = await supabase
  .from('users')
  .select('*')
  .eq('email', email)

// ✅ Safe - parameterized (raw SQL)
const result = await db.query(
  'SELECT * FROM users WHERE email = $1',
  [email]
)
```

### Supabase RLS as Defense Layer
```sql
-- Even if query is compromised, RLS limits access
ALTER TABLE user_data ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users see own data" ON user_data
  FOR SELECT USING (auth.uid() = user_id);
```

---

## Authentication Security

### Password Handling
```typescript
import bcrypt from 'bcrypt'

const SALT_ROUNDS = 12

// Hash password
async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, SALT_ROUNDS)
}

// Verify password
async function verifyPassword(password: string, hash: string): Promise<boolean> {
  return bcrypt.compare(password, hash)
}

// Password requirements
const PasswordSchema = z.string()
  .min(8, 'At least 8 characters')
  .regex(/[A-Z]/, 'At least one uppercase')
  .regex(/[a-z]/, 'At least one lowercase')
  .regex(/[0-9]/, 'At least one number')
  .regex(/[^A-Za-z0-9]/, 'At least one special character')
```

### JWT Best Practices
```typescript
import jwt from 'jsonwebtoken'

const JWT_SECRET = process.env.JWT_SECRET!
const JWT_EXPIRES = '15m'      // Short-lived access token
const REFRESH_EXPIRES = '7d'   // Longer refresh token

// Generate tokens
function generateTokens(userId: string) {
  const accessToken = jwt.sign(
    { userId, type: 'access' },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  )
  
  const refreshToken = jwt.sign(
    { userId, type: 'refresh' },
    JWT_SECRET,
    { expiresIn: REFRESH_EXPIRES }
  )
  
  return { accessToken, refreshToken }
}

// Verify token
function verifyToken(token: string) {
  try {
    return jwt.verify(token, JWT_SECRET)
  } catch {
    return null
  }
}
```

### Session Security
```typescript
// Secure cookie settings
const sessionOptions = {
  httpOnly: true,      // No JavaScript access
  secure: true,        // HTTPS only
  sameSite: 'strict',  // CSRF protection
  maxAge: 15 * 60 * 1000, // 15 minutes
  path: '/',
}

// Regenerate session after login
async function login(user: User) {
  await regenerateSession()
  session.userId = user.id
}
```

---

## CSRF Protection

### Token-Based Protection
```typescript
import crypto from 'crypto'

// Generate CSRF token
function generateCsrfToken(): string {
  return crypto.randomBytes(32).toString('hex')
}

// Store in session
session.csrfToken = generateCsrfToken()

// Verify on requests
function verifyCsrf(req: Request) {
  const token = req.headers['x-csrf-token']
  if (token !== session.csrfToken) {
    throw new Error('CSRF token mismatch')
  }
}
```

### SameSite Cookies
```typescript
// Modern CSRF protection via cookie settings
res.cookie('session', sessionId, {
  sameSite: 'strict', // Or 'lax' for GET navigation
  httpOnly: true,
  secure: true,
})
```

---

## Secrets Management

### Environment Variables
```bash
# .env (NEVER commit!)
DATABASE_URL=postgres://...
JWT_SECRET=super-secret-key-here
API_KEY=sk-...

# .env.example (commit this)
DATABASE_URL=postgres://user:pass@localhost:5432/db
JWT_SECRET=your-secret-here
API_KEY=your-api-key
```

### Runtime Validation
```typescript
// Validate required env vars at startup
const requiredEnvVars = [
  'DATABASE_URL',
  'JWT_SECRET',
  'SUPABASE_URL',
  'SUPABASE_KEY',
] as const

for (const envVar of requiredEnvVars) {
  if (!process.env[envVar]) {
    throw new Error(`Missing required env var: ${envVar}`)
  }
}
```

### Client-Side Safety
```typescript
// ✅ Public keys only (NEXT_PUBLIC_, VITE_)
const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY

// ❌ Never expose in client
// Service role key, JWT secret, API secrets
```

---

## Rate Limiting

### Basic Implementation
```typescript
const rateLimit = new Map<string, { count: number; resetTime: number }>()

const WINDOW_MS = 60 * 1000  // 1 minute
const MAX_REQUESTS = 100

function checkRateLimit(ip: string): boolean {
  const now = Date.now()
  const record = rateLimit.get(ip)
  
  if (!record || now > record.resetTime) {
    rateLimit.set(ip, { count: 1, resetTime: now + WINDOW_MS })
    return true
  }
  
  if (record.count >= MAX_REQUESTS) {
    return false
  }
  
  record.count++
  return true
}
```

### Per-Endpoint Limits
```typescript
const limits = {
  '/api/auth/login': { window: 60000, max: 5 },     // 5/min
  '/api/auth/register': { window: 3600000, max: 3 }, // 3/hour
  '/api/upload': { window: 60000, max: 10 },         // 10/min
  default: { window: 60000, max: 100 },              // 100/min
}
```

---

## Security Headers

### Essential Headers
```typescript
// Next.js - next.config.js
const securityHeaders = [
  {
    key: 'X-Content-Type-Options',
    value: 'nosniff',
  },
  {
    key: 'X-Frame-Options',
    value: 'DENY',
  },
  {
    key: 'X-XSS-Protection',
    value: '1; mode=block',
  },
  {
    key: 'Referrer-Policy',
    value: 'strict-origin-when-cross-origin',
  },
  {
    key: 'Permissions-Policy',
    value: 'camera=(), microphone=(), geolocation=()',
  },
]

// Content Security Policy
const cspHeader = {
  key: 'Content-Security-Policy',
  value: [
    "default-src 'self'",
    "script-src 'self' 'unsafe-inline' 'unsafe-eval'",
    "style-src 'self' 'unsafe-inline'",
    "img-src 'self' data: https:",
    "font-src 'self'",
    "connect-src 'self' https://api.example.com",
  ].join('; '),
}
```

---

## Error Handling Security

### Don't Leak Information
```typescript
// ❌ Exposes internal details
catch (error) {
  res.status(500).json({ error: error.message, stack: error.stack })
}

// ✅ Generic message, log internally
catch (error) {
  console.error('Internal error:', error)
  res.status(500).json({ error: 'Internal server error' })
}

// ✅ Specific but safe messages
catch (error) {
  if (error instanceof ValidationError) {
    return res.status(400).json({ error: 'Invalid input' })
  }
  if (error instanceof AuthError) {
    return res.status(401).json({ error: 'Authentication failed' })
  }
  console.error('Unexpected error:', error)
  return res.status(500).json({ error: 'Something went wrong' })
}
```

### Timing Attack Prevention
```typescript
import crypto from 'crypto'

// ❌ Vulnerable to timing attacks
if (userToken === storedToken) { ... }

// ✅ Constant-time comparison
if (crypto.timingSafeEqual(
  Buffer.from(userToken),
  Buffer.from(storedToken)
)) { ... }
```

---

## Security Checklist

### Before Production
```
[ ] All inputs validated server-side
[ ] Passwords hashed with bcrypt/argon2
[ ] JWT tokens short-lived with refresh
[ ] HTTPS enforced
[ ] Security headers configured
[ ] Rate limiting enabled
[ ] CORS properly configured
[ ] Secrets in environment variables
[ ] Error messages don't leak info
[ ] SQL injection prevented (parameterized queries)
[ ] XSS prevented (output encoding)
[ ] CSRF protection enabled
[ ] File uploads validated
[ ] Dependency vulnerabilities checked (npm audit)
[ ] Logging enabled (without sensitive data)
```

### Regular Maintenance
```
[ ] Run npm audit weekly
[ ] Review access logs
[ ] Rotate secrets periodically
[ ] Update dependencies
[ ] Test backup restoration
[ ] Review user permissions
```

---

## Avoid

- Storing passwords in plain text
- Using MD5/SHA1 for passwords (use bcrypt)
- Trusting client-side validation alone
- Exposing stack traces to users
- Committing secrets to git
- Using `eval()` with user input
- Disabling HTTPS
- Overly permissive CORS
- Long-lived JWTs without refresh
- Storing sensitive data in localStorage
