# React 18+ Skill

> Patterns for React 18+ with TypeScript. For medium-large projects or when team prefers React ecosystem.

**When to use:** See `framework-philosophy.skill` for project size decision matrix.

---

## Project Setup

### Recommended Stack
```
React 18 + Vite + TypeScript + Zustand + React Router + Tailwind CSS
```

### Create Project
```bash
npm create vite@latest my-app -- --template react-ts
cd my-app
npm install
npm install -D @types/node

# Essential packages
npm install zustand react-router-dom @tanstack/react-query
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p
```

### Project Structure
```
src/
├── features/               # Feature modules (see framework-philosophy.skill)
│   ├── auth/
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── services/
│   │   ├── types/
│   │   └── index.ts
│   └── projects/
├── shared/                 # Cross-feature shared code
│   ├── components/         # Reusable UI components
│   │   └── ui/             # Base components (Button, Input, Modal)
│   ├── hooks/              # Shared hooks
│   ├── services/           # API clients, utilities
│   └── types/              # Shared TypeScript types
├── app/                    # App shell
│   ├── routes/             # Route definitions
│   ├── providers/          # Context providers
│   └── App.tsx
├── styles/                 # Global styles
│   └── globals.css
└── main.tsx                # Entry point
```

---

## Component Patterns

### Function Component
```tsx
import { useState, useMemo, useEffect } from 'react'
import type { Project } from '@/types'

interface Props {
  project: Project
  editable?: boolean
  onUpdate?: (project: Project) => void
  onDelete?: (id: string) => void
}

export function ProjectCard({
  project,
  editable = false,
  onUpdate,
  onDelete
}: Props) {
  // State
  const [isLoading, setIsLoading] = useState(false)
  const [localName, setLocalName] = useState(project.name)

  // Computed
  const displayName = useMemo(() => localName.toUpperCase(), [localName])

  // Effects
  useEffect(() => {
    console.log('Component mounted')
    return () => console.log('Component unmounted')
  }, [])

  // Handlers
  function handleSave() {
    onUpdate?.({ ...project, name: localName })
  }

  return (
    <div className="project-card">
      <h2>{displayName}</h2>
      {editable && (
        <input
          value={localName}
          onChange={(e) => setLocalName(e.target.value)}
        />
      )}
      <button onClick={handleSave}>Save</button>
    </div>
  )
}
```

### Props with Children
```tsx
interface CardProps {
  title: string
  children: React.ReactNode
  footer?: React.ReactNode
}

export function Card({ title, children, footer }: CardProps) {
  return (
    <div className="card">
      <header>{title}</header>
      <main>{children}</main>
      {footer && <footer>{footer}</footer>}
    </div>
  )
}

// Usage
<Card title="My Card" footer={<button>Action</button>}>
  <p>Card content goes here</p>
</Card>
```

### Controlled Input Component
```tsx
interface InputProps {
  value: string
  onChange: (value: string) => void
  placeholder?: string
  type?: 'text' | 'email' | 'password'
}

export function Input({
  value,
  onChange,
  placeholder,
  type = 'text'
}: InputProps) {
  return (
    <input
      type={type}
      value={value}
      onChange={(e) => onChange(e.target.value)}
      placeholder={placeholder}
      className="input"
    />
  )
}
```

### forwardRef Pattern
```tsx
import { forwardRef } from 'react'

interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  label?: string
  error?: string
}

export const Input = forwardRef<HTMLInputElement, InputProps>(
  ({ label, error, className, ...props }, ref) => {
    return (
      <div className="input-wrapper">
        {label && <label>{label}</label>}
        <input ref={ref} className={className} {...props} />
        {error && <span className="error">{error}</span>}
      </div>
    )
  }
)

Input.displayName = 'Input'
```

---

## Hooks

### useState
```tsx
// Simple state
const [count, setCount] = useState(0)

// Object state
const [form, setForm] = useState({ name: '', email: '' })
const updateField = (field: string, value: string) => {
  setForm(prev => ({ ...prev, [field]: value }))
}

// Lazy initialization (expensive computation)
const [data, setData] = useState(() => computeExpensiveValue())
```

### useEffect
```tsx
// Run on mount only
useEffect(() => {
  console.log('Mounted')
}, [])

// Run when dependency changes
useEffect(() => {
  fetchUser(userId)
}, [userId])

// Cleanup
useEffect(() => {
  const subscription = subscribeToEvents()
  return () => subscription.unsubscribe()
}, [])

// Async effect pattern
useEffect(() => {
  let cancelled = false

  async function fetchData() {
    const result = await api.get('/data')
    if (!cancelled) {
      setData(result)
    }
  }

  fetchData()
  return () => { cancelled = true }
}, [])
```

### useMemo & useCallback
```tsx
// Memoize expensive computation
const sortedItems = useMemo(() => {
  return items.sort((a, b) => a.name.localeCompare(b.name))
}, [items])

// Memoize callback to prevent child re-renders
const handleClick = useCallback((id: string) => {
  setSelected(id)
}, [])

// When NOT to use:
// - Simple calculations
// - Primitive values
// - Functions that don't cause re-renders
```

### useRef
```tsx
// DOM reference
const inputRef = useRef<HTMLInputElement>(null)
const focusInput = () => inputRef.current?.focus()

// Mutable value (doesn't trigger re-render)
const renderCount = useRef(0)
renderCount.current += 1

// Previous value pattern
const prevValue = useRef(value)
useEffect(() => {
  prevValue.current = value
}, [value])
```

---

## Custom Hooks

### Data Fetching Hook
```tsx
// hooks/useProjects.ts
import { useState, useCallback } from 'react'
import { projectService } from '@/services/projectService'
import type { Project } from '@/types'

export function useProjects() {
  const [projects, setProjects] = useState<Project[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const fetch = useCallback(async () => {
    setIsLoading(true)
    setError(null)
    try {
      const data = await projectService.getAll()
      setProjects(data)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error')
    } finally {
      setIsLoading(false)
    }
  }, [])

  const create = useCallback(async (project: ProjectCreate) => {
    const created = await projectService.create(project)
    setProjects(prev => [created, ...prev])
    return created
  }, [])

  return { projects, isLoading, error, fetch, create }
}
```

### Form Hook
```tsx
// hooks/useForm.ts
import { useState, useCallback } from 'react'

interface UseFormOptions<T> {
  initialValues: T
  onSubmit: (values: T) => Promise<void>
  validate?: (values: T) => Record<string, string>
}

export function useForm<T extends Record<string, any>>({
  initialValues,
  onSubmit,
  validate
}: UseFormOptions<T>) {
  const [values, setValues] = useState<T>(initialValues)
  const [errors, setErrors] = useState<Record<string, string>>({})
  const [isSubmitting, setIsSubmitting] = useState(false)

  const handleChange = useCallback((field: keyof T, value: any) => {
    setValues(prev => ({ ...prev, [field]: value }))
    setErrors(prev => ({ ...prev, [field]: '' }))
  }, [])

  const handleSubmit = useCallback(async (e: React.FormEvent) => {
    e.preventDefault()

    if (validate) {
      const validationErrors = validate(values)
      if (Object.keys(validationErrors).length > 0) {
        setErrors(validationErrors)
        return
      }
    }

    setIsSubmitting(true)
    try {
      await onSubmit(values)
    } finally {
      setIsSubmitting(false)
    }
  }, [values, validate, onSubmit])

  const reset = useCallback(() => {
    setValues(initialValues)
    setErrors({})
  }, [initialValues])

  return { values, errors, isSubmitting, handleChange, handleSubmit, reset }
}
```

### Subscription Hook with Cleanup
```tsx
// hooks/useRealtimeProjects.ts
import { useEffect } from 'react'
import { supabase } from '@/lib/supabase'

export function useRealtimeProjects(onUpdate: (payload: any) => void) {
  useEffect(() => {
    const channel = supabase
      .channel('projects-changes')
      .on('postgres_changes',
        { event: '*', schema: 'public', table: 'projects' },
        onUpdate
      )
      .subscribe()

    return () => {
      supabase.removeChannel(channel)
    }
  }, [onUpdate])
}
```

---

## State Management (Zustand)

### Basic Store
```tsx
// stores/projectStore.ts
import { create } from 'zustand'
import { projectService } from '@/services/projectService'
import type { Project } from '@/types'

interface ProjectState {
  projects: Project[]
  currentProject: Project | null
  isLoading: boolean
  error: string | null

  // Actions
  fetchProjects: () => Promise<void>
  setCurrentProject: (project: Project | null) => void
  createProject: (data: ProjectCreate) => Promise<Project>
  updateProject: (id: string, data: ProjectUpdate) => Promise<void>
  deleteProject: (id: string) => Promise<void>
}

export const useProjectStore = create<ProjectState>((set, get) => ({
  projects: [],
  currentProject: null,
  isLoading: false,
  error: null,

  fetchProjects: async () => {
    set({ isLoading: true, error: null })
    try {
      const projects = await projectService.getAll()
      set({ projects, isLoading: false })
    } catch (err) {
      set({ error: err.message, isLoading: false })
    }
  },

  setCurrentProject: (project) => set({ currentProject: project }),

  createProject: async (data) => {
    const project = await projectService.create(data)
    set(state => ({ projects: [project, ...state.projects] }))
    return project
  },

  updateProject: async (id, data) => {
    const updated = await projectService.update(id, data)
    set(state => ({
      projects: state.projects.map(p => p.id === id ? updated : p),
      currentProject: state.currentProject?.id === id ? updated : state.currentProject
    }))
  },

  deleteProject: async (id) => {
    await projectService.delete(id)
    set(state => ({
      projects: state.projects.filter(p => p.id !== id),
      currentProject: state.currentProject?.id === id ? null : state.currentProject
    }))
  }
}))
```

### Using Store in Components
```tsx
// Selector pattern (prevents unnecessary re-renders)
const projects = useProjectStore(state => state.projects)
const isLoading = useProjectStore(state => state.isLoading)
const fetchProjects = useProjectStore(state => state.fetchProjects)

// Multiple selectors
const { projects, isLoading } = useProjectStore(state => ({
  projects: state.projects,
  isLoading: state.isLoading
}))

// In component
useEffect(() => {
  fetchProjects()
}, [fetchProjects])
```

### Store with Persist
```tsx
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

export const useSettingsStore = create(
  persist<SettingsState>(
    (set) => ({
      theme: 'light',
      sidebarCollapsed: false,
      toggleTheme: () => set(state => ({
        theme: state.theme === 'light' ? 'dark' : 'light'
      })),
    }),
    { name: 'settings-storage' }
  )
)
```

---

## React Router

### Route Setup
```tsx
// app/routes/index.tsx
import { createBrowserRouter, RouterProvider } from 'react-router-dom'
import { MainLayout } from '@/app/layouts/MainLayout'

const router = createBrowserRouter([
  {
    path: '/',
    element: <MainLayout />,
    children: [
      { index: true, element: <Dashboard /> },
      { path: 'projects', element: <ProjectList /> },
      { path: 'projects/:id', element: <ProjectDetail /> },
      { path: 'settings', element: <Settings /> },
    ]
  },
  { path: '/login', element: <Login /> },
  { path: '*', element: <NotFound /> }
])

export function AppRouter() {
  return <RouterProvider router={router} />
}
```

### Using Router
```tsx
import { useParams, useNavigate, useSearchParams } from 'react-router-dom'

function ProjectDetail() {
  const { id } = useParams<{ id: string }>()
  const navigate = useNavigate()
  const [searchParams, setSearchParams] = useSearchParams()

  const tab = searchParams.get('tab') || 'overview'

  const goBack = () => navigate(-1)
  const goToProjects = () => navigate('/projects')
  const setTab = (tab: string) => setSearchParams({ tab })

  return (...)
}
```

### Protected Route
```tsx
// components/ProtectedRoute.tsx
import { Navigate, Outlet } from 'react-router-dom'
import { useAuthStore } from '@/stores/authStore'

export function ProtectedRoute() {
  const isAuthenticated = useAuthStore(state => state.isAuthenticated)

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />
  }

  return <Outlet />
}

// Usage in router
{
  element: <ProtectedRoute />,
  children: [
    { path: 'dashboard', element: <Dashboard /> },
  ]
}
```

---

## Context Pattern

### Creating Context
```tsx
// contexts/ThemeContext.tsx
import { createContext, useContext, useState, ReactNode } from 'react'

interface ThemeContextType {
  theme: 'light' | 'dark'
  toggleTheme: () => void
}

const ThemeContext = createContext<ThemeContextType | null>(null)

export function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState<'light' | 'dark'>('light')

  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light')
  }

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  )
}

export function useTheme() {
  const context = useContext(ThemeContext)
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider')
  }
  return context
}
```

---

## Testing Patterns

### Component Testing
```tsx
// __tests__/ProjectCard.test.tsx
import { render, screen, fireEvent } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { ProjectCard } from '../ProjectCard'

const mockProject = {
  id: '1',
  name: 'Test Project',
  status: 'active'
}

describe('ProjectCard', () => {
  test('renders project name', () => {
    render(<ProjectCard project={mockProject} />)
    expect(screen.getByText('TEST PROJECT')).toBeInTheDocument()
  })

  test('calls onUpdate when save clicked', async () => {
    const onUpdate = vi.fn()
    render(<ProjectCard project={mockProject} editable onUpdate={onUpdate} />)

    await userEvent.clear(screen.getByRole('textbox'))
    await userEvent.type(screen.getByRole('textbox'), 'New Name')
    await userEvent.click(screen.getByRole('button', { name: /save/i }))

    expect(onUpdate).toHaveBeenCalledWith({
      ...mockProject,
      name: 'New Name'
    })
  })
})
```

### Hook Testing
```tsx
// __tests__/useProjects.test.tsx
import { renderHook, waitFor } from '@testing-library/react'
import { useProjects } from '../useProjects'

vi.mock('@/services/projectService', () => ({
  projectService: {
    getAll: vi.fn().mockResolvedValue([{ id: '1', name: 'Test' }])
  }
}))

describe('useProjects', () => {
  test('fetches projects', async () => {
    const { result } = renderHook(() => useProjects())

    await result.current.fetch()

    await waitFor(() => {
      expect(result.current.projects).toHaveLength(1)
      expect(result.current.isLoading).toBe(false)
    })
  })
})
```

---

## Performance Optimization

### React.memo
```tsx
// Prevent re-render when props haven't changed
const ProjectCard = React.memo(function ProjectCard({ project }: Props) {
  return (...)
})

// With custom comparison
const ProjectCard = React.memo(
  function ProjectCard({ project }: Props) { ... },
  (prevProps, nextProps) => prevProps.project.id === nextProps.project.id
)
```

### Lazy Loading
```tsx
// Route-level code splitting
const Dashboard = lazy(() => import('@/features/dashboard'))
const Projects = lazy(() => import('@/features/projects'))

// With Suspense
<Suspense fallback={<LoadingSpinner />}>
  <Dashboard />
</Suspense>
```

### List Virtualization
```tsx
// For large lists, use @tanstack/react-virtual
import { useVirtualizer } from '@tanstack/react-virtual'

function VirtualList({ items }) {
  const parentRef = useRef<HTMLDivElement>(null)

  const virtualizer = useVirtualizer({
    count: items.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 50,
  })

  return (
    <div ref={parentRef} style={{ height: '400px', overflow: 'auto' }}>
      <div style={{ height: virtualizer.getTotalSize() }}>
        {virtualizer.getVirtualItems().map(virtualItem => (
          <div key={virtualItem.key} style={{
            position: 'absolute',
            top: virtualItem.start,
            height: virtualItem.size
          }}>
            {items[virtualItem.index].name}
          </div>
        ))}
      </div>
    </div>
  )
}
```

---

## Avoid

- Class components (use function components)
- PropTypes (use TypeScript)
- Excessive Context (use Zustand for global state)
- Inline functions in JSX (memoize with useCallback if causing issues)
- Missing keys in lists
- Direct state mutation
- useEffect for derived state (use useMemo)
- Forgetting cleanup in useEffect
