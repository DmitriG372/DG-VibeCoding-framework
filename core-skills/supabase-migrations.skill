# Supabase Migrations Skill

> Advanced patterns for Supabase migration workflows, rollbacks, and production deployment.

---

## Migration Architecture

### Directory Structure
```
/database/
├── migrations/           # Versioned schema changes (append-only!)
│   ├── 0001_initial_schema.sql
│   ├── 0002_add_projects_table.sql
│   └── 0003_add_user_roles.sql
├── tables/               # Current table definitions (reference only)
│   ├── users.sql
│   ├── projects.sql
│   └── tasks.sql
├── policies/             # RLS policies (organized by table)
│   ├── users_policies.sql
│   └── projects_policies.sql
├── seeds/                # Test and reference data
│   ├── core.sql          # Always needed (roles, settings)
│   ├── test.sql          # Development data
│   └── demo.sql          # Demo environment data
├── functions/            # Database functions and triggers
│   └── common_triggers.sql
└── index.json            # Migration registry
```

---

## Migration File Format

### Naming Convention
```
{sequence}_{description}.sql

Examples:
0001_initial_schema.sql
0002_add_projects_table.sql
0003_alter_users_add_role.sql
0004_create_audit_log.sql
```

### File Template
```sql
-- Migration: 0002_add_projects_table
-- Description: Create projects table with RLS
-- Author: [name]
-- Date: 2025-11-25

-- ============================================
-- UP: Apply changes
-- ============================================

-- Create table
CREATE TABLE IF NOT EXISTS projects (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT,
  status TEXT DEFAULT 'draft' CHECK (status IN ('draft', 'active', 'completed', 'archived')),
  owner_id UUID REFERENCES auth.users(id) NOT NULL DEFAULT auth.uid(),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_projects_owner ON projects(owner_id);
CREATE INDEX IF NOT EXISTS idx_projects_status ON projects(status);

-- Enable RLS
ALTER TABLE projects ENABLE ROW LEVEL SECURITY;

-- Policies
CREATE POLICY "Users can view own projects"
  ON projects FOR SELECT
  USING (owner_id = auth.uid());

CREATE POLICY "Users can create own projects"
  ON projects FOR INSERT
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "Users can update own projects"
  ON projects FOR UPDATE
  USING (owner_id = auth.uid());

CREATE POLICY "Users can delete own projects"
  ON projects FOR DELETE
  USING (owner_id = auth.uid());

-- Trigger for updated_at
CREATE TRIGGER set_projects_updated_at
  BEFORE UPDATE ON projects
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at();

-- ============================================
-- DOWN: Rollback (keep for reference)
-- ============================================
/*
DROP TRIGGER IF EXISTS set_projects_updated_at ON projects;
DROP POLICY IF EXISTS "Users can delete own projects" ON projects;
DROP POLICY IF EXISTS "Users can update own projects" ON projects;
DROP POLICY IF EXISTS "Users can create own projects" ON projects;
DROP POLICY IF EXISTS "Users can view own projects" ON projects;
DROP INDEX IF EXISTS idx_projects_status;
DROP INDEX IF EXISTS idx_projects_owner;
DROP TABLE IF EXISTS projects;
*/
```

---

## Migration Registry (index.json)

```json
{
  "version": "1.0",
  "migrations": [
    {
      "id": "0001",
      "name": "initial_schema",
      "file": "0001_initial_schema.sql",
      "checksum": "sha256:abc123...",
      "applied_at": null,
      "description": "Base tables and functions"
    },
    {
      "id": "0002",
      "name": "add_projects_table",
      "file": "0002_add_projects_table.sql",
      "checksum": "sha256:def456...",
      "applied_at": null,
      "description": "Projects table with RLS"
    }
  ],
  "current_version": null
}
```

---

## Migrations Table (in Supabase)

```sql
-- Run this FIRST in Supabase SQL editor
CREATE TABLE IF NOT EXISTS _migrations (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL UNIQUE,
  checksum TEXT NOT NULL,
  applied_at TIMESTAMPTZ DEFAULT NOW(),
  applied_by TEXT,
  execution_time_ms INTEGER
);

-- Index for quick lookups
CREATE INDEX IF NOT EXISTS idx_migrations_name ON _migrations(name);

-- Comment
COMMENT ON TABLE _migrations IS 'Tracks applied database migrations (append-only)';
```

---

## Migration Runner (Node.js)

```typescript
// scripts/migrate.ts
import { createClient } from '@supabase/supabase-js'
import { readFileSync, readdirSync } from 'fs'
import { createHash } from 'crypto'
import path from 'path'

const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_KEY! // Service role for migrations
)

interface Migration {
  name: string
  file: string
  checksum: string
  sql: string
}

async function getMigrationFiles(): Promise<Migration[]> {
  const migrationsDir = path.join(__dirname, '../database/migrations')
  const files = readdirSync(migrationsDir)
    .filter(f => f.endsWith('.sql'))
    .sort()

  return files.map(file => {
    const sql = readFileSync(path.join(migrationsDir, file), 'utf-8')
    const checksum = createHash('sha256').update(sql).digest('hex')
    return {
      name: file.replace('.sql', ''),
      file,
      checksum,
      sql
    }
  })
}

async function getAppliedMigrations(): Promise<string[]> {
  const { data, error } = await supabase
    .from('_migrations')
    .select('name')
    .order('id')

  if (error) throw error
  return data.map(m => m.name)
}

async function applyMigration(migration: Migration): Promise<void> {
  const startTime = Date.now()

  console.log(`Applying: ${migration.name}...`)

  // Execute migration SQL
  const { error } = await supabase.rpc('exec_sql', {
    sql_query: migration.sql
  })

  if (error) {
    throw new Error(`Migration ${migration.name} failed: ${error.message}`)
  }

  // Record migration
  const executionTime = Date.now() - startTime
  await supabase.from('_migrations').insert({
    name: migration.name,
    checksum: migration.checksum,
    applied_by: 'migration-script',
    execution_time_ms: executionTime
  })

  console.log(`✓ Applied: ${migration.name} (${executionTime}ms)`)
}

async function migrate() {
  try {
    const allMigrations = await getMigrationFiles()
    const appliedMigrations = await getAppliedMigrations()

    const pendingMigrations = allMigrations.filter(
      m => !appliedMigrations.includes(m.name)
    )

    if (pendingMigrations.length === 0) {
      console.log('No pending migrations.')
      return
    }

    console.log(`Found ${pendingMigrations.length} pending migration(s)`)

    for (const migration of pendingMigrations) {
      await applyMigration(migration)
    }

    console.log('\n✓ All migrations applied successfully!')
  } catch (error) {
    console.error('Migration failed:', error)
    process.exit(1)
  }
}

migrate()
```

---

## Rollback Strategy

### Approach 1: Manual Rollback Script
```sql
-- rollback/0002_add_projects_table.sql
-- DANGER: Only use in development or with explicit approval

BEGIN;

-- Verify we're rolling back the correct migration
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM _migrations WHERE name = '0002_add_projects_table'
  ) THEN
    RAISE EXCEPTION 'Migration 0002_add_projects_table not found';
  END IF;
END $$;

-- Execute rollback
DROP TRIGGER IF EXISTS set_projects_updated_at ON projects;
DROP POLICY IF EXISTS "Users can delete own projects" ON projects;
DROP POLICY IF EXISTS "Users can update own projects" ON projects;
DROP POLICY IF EXISTS "Users can create own projects" ON projects;
DROP POLICY IF EXISTS "Users can view own projects" ON projects;
DROP INDEX IF EXISTS idx_projects_status;
DROP INDEX IF EXISTS idx_projects_owner;
DROP TABLE IF EXISTS projects;

-- Remove migration record
DELETE FROM _migrations WHERE name = '0002_add_projects_table';

COMMIT;
```

### Approach 2: Compensating Migration
```sql
-- 0005_revert_projects_status_change.sql
-- Instead of rollback, create new migration that undoes changes

ALTER TABLE projects
  DROP CONSTRAINT IF EXISTS projects_status_check;

ALTER TABLE projects
  ADD CONSTRAINT projects_status_check
  CHECK (status IN ('draft', 'active', 'completed')); -- Removed 'archived'
```

---

## Safe Migration Patterns

### Adding Column (Safe)
```sql
-- Always safe - no locks on existing data
ALTER TABLE users ADD COLUMN IF NOT EXISTS phone TEXT;
```

### Adding Column with Default (PostgreSQL 11+)
```sql
-- Safe in PostgreSQL 11+ - no table rewrite
ALTER TABLE users ADD COLUMN role TEXT DEFAULT 'user';
```

### Renaming Column (Careful!)
```sql
-- Create new column
ALTER TABLE users ADD COLUMN full_name TEXT;

-- Copy data
UPDATE users SET full_name = name;

-- In next migration (after app update):
-- ALTER TABLE users DROP COLUMN name;
```

### Changing Column Type (Careful!)
```sql
-- Safe: VARCHAR → TEXT
ALTER TABLE users ALTER COLUMN name TYPE TEXT;

-- Unsafe: TEXT → INTEGER (requires USING)
ALTER TABLE users ALTER COLUMN age TYPE INTEGER USING age::integer;
```

### Adding NOT NULL (Two-Step)
```sql
-- Step 1: Add column without NOT NULL
ALTER TABLE users ADD COLUMN email TEXT;

-- Step 2: Backfill data
UPDATE users SET email = 'unknown@example.com' WHERE email IS NULL;

-- Step 3 (next migration): Add constraint
ALTER TABLE users ALTER COLUMN email SET NOT NULL;
```

---

## Environment-Specific Migrations

### Development vs Production
```typescript
// In migration runner
const isProduction = process.env.NODE_ENV === 'production'

if (isProduction) {
  // Extra safety checks
  console.log('⚠️  PRODUCTION MIGRATION')
  console.log('Migrations to apply:')
  pendingMigrations.forEach(m => console.log(`  - ${m.name}`))

  const readline = require('readline')
  const rl = readline.createInterface({ input: process.stdin, output: process.stdout })

  await new Promise<void>((resolve) => {
    rl.question('Continue? (yes/no): ', (answer) => {
      if (answer !== 'yes') {
        console.log('Aborted.')
        process.exit(0)
      }
      resolve()
    })
  })
}
```

---

## CI/CD Integration

### GitHub Actions Example
```yaml
# .github/workflows/migrate.yml
name: Database Migration

on:
  push:
    branches: [main]
    paths:
      - 'database/migrations/**'

jobs:
  migrate-staging:
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm ci

      - name: Run migrations (staging)
        env:
          SUPABASE_URL: ${{ secrets.STAGING_SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.STAGING_SUPABASE_SERVICE_KEY }}
        run: npm run migrate

  migrate-production:
    needs: migrate-staging
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm ci

      - name: Run migrations (production)
        env:
          SUPABASE_URL: ${{ secrets.PROD_SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.PROD_SUPABASE_SERVICE_KEY }}
        run: npm run migrate
```

---

## Pre-Production Checklist

### Before Deploying Migration
```markdown
- [ ] Migration tested locally
- [ ] Migration tested on staging
- [ ] Rollback script prepared (if needed)
- [ ] Backup taken (for destructive changes)
- [ ] App code compatible with both old and new schema
- [ ] Migration time estimated (large tables)
- [ ] Maintenance window scheduled (if needed)
- [ ] Team notified
```

### After Deployment
```markdown
- [ ] Migration applied successfully
- [ ] App functioning correctly
- [ ] No errors in logs
- [ ] Performance acceptable
- [ ] Rollback scripts archived (not deleted)
```

---

## Common Issues & Solutions

### Issue: Migration Timeout
```sql
-- For large table updates, use batching
DO $$
DECLARE
  batch_size INT := 10000;
  affected INT;
BEGIN
  LOOP
    UPDATE users
    SET migrated = true
    WHERE id IN (
      SELECT id FROM users
      WHERE migrated IS NULL
      LIMIT batch_size
    );

    GET DIAGNOSTICS affected = ROW_COUNT;
    EXIT WHEN affected = 0;

    RAISE NOTICE 'Updated % rows', affected;
    COMMIT;
  END LOOP;
END $$;
```

### Issue: Lock Contention
```sql
-- Use lock_timeout for DDL
SET lock_timeout = '5s';
ALTER TABLE users ADD COLUMN new_col TEXT;
RESET lock_timeout;
```

### Issue: Checksum Mismatch
```typescript
// In migration runner
const applied = await getAppliedMigration(migration.name)
if (applied && applied.checksum !== migration.checksum) {
  throw new Error(
    `Checksum mismatch for ${migration.name}. ` +
    `Migration file was modified after being applied!`
  )
}
```

---

## Avoid

- Modifying already-applied migrations
- Running migrations without backup (production)
- Dropping columns/tables without deprecation period
- Large data migrations during peak hours
- Skipping staging environment
- Manual SQL changes outside migration system
- Storing sensitive data in migration files
