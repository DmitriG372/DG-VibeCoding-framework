# Debugging Skill

> Systematic debugging techniques for web development.

---

## Console Methods

### Beyond console.log
```typescript
// Styled output
console.log("%cImportant!", "color: red; font-size: 20px")

// Table for arrays/objects
console.table([{ id: 1, name: "A" }, { id: 2, name: "B" }])

// Grouped logs
console.group("User Flow")
console.log("Step 1: Login")
console.log("Step 2: Dashboard")
console.groupEnd()

// Collapsed group
console.groupCollapsed("Details")
console.log("Hidden by default")
console.groupEnd()

// Timing
console.time("fetch")
await fetchData()
console.timeEnd("fetch") // fetch: 234.56ms

// Count calls
function onClick() {
  console.count("click") // click: 1, click: 2, ...
}

// Assertions
console.assert(user !== null, "User should exist")

// Stack trace
console.trace("How did we get here?")

// Clear
console.clear()
```

### Structured Logging
```typescript
// Debug levels
const log = {
  debug: (...args: unknown[]) => console.debug("[DEBUG]", ...args),
  info: (...args: unknown[]) => console.info("[INFO]", ...args),
  warn: (...args: unknown[]) => console.warn("[WARN]", ...args),
  error: (...args: unknown[]) => console.error("[ERROR]", ...args),
}

// With context
function logWithContext(context: string) {
  return {
    debug: (...args: unknown[]) => console.debug(`[${context}]`, ...args),
    error: (...args: unknown[]) => console.error(`[${context}]`, ...args),
  }
}

const authLog = logWithContext("Auth")
authLog.debug("Login attempt", { email })
```

---

## Chrome DevTools

### Sources Panel

**Breakpoints**
```typescript
// Conditional breakpoint (right-click line number)
// Break only when: user.role === "admin"

// Logpoint (no pause, just log)
// Log: "User:", user.name

// Programmatic breakpoint
debugger // Pauses execution here
```

**Watch Expressions**
- Add variables to watch panel
- Evaluate expressions in real-time

**Call Stack**
- Navigate up/down the call stack
- See async call chains

**Scope**
- Local, Closure, Global variables
- Inspect `this` context

### Network Panel

**Filter requests**
```
# By type
fetch XHR

# By domain
domain:api.example.com

# By status
status-code:404

# Negative filter
-status-code:200
```

**Useful columns**
- Waterfall: timing visualization
- Size: transfer vs actual size
- Time: total request time
- Initiator: what triggered request

**Copy as**
- Copy as cURL (for terminal)
- Copy as fetch (for code)

### Performance Panel

**Recording**
1. Click record
2. Perform action
3. Stop recording
4. Analyze flame chart

**Key metrics**
- FCP (First Contentful Paint)
- LCP (Largest Contentful Paint)
- TBT (Total Blocking Time)
- CLS (Cumulative Layout Shift)

### Memory Panel

**Heap snapshot**
1. Take snapshot
2. Filter by constructor
3. Look for detached DOM nodes
4. Compare snapshots for leaks

**Allocation timeline**
- See memory allocation over time
- Identify memory growth patterns

---

## Vue DevTools

### Component Inspector
- View component hierarchy
- Edit props in real-time
- See computed values
- Inspect slots

### Pinia Tab
- View all stores
- Edit state directly
- Time-travel debugging
- Track mutations

### Timeline
- Component events
- Performance metrics
- Vuex/Pinia mutations

### Useful Commands
```javascript
// In console when component selected
$vm              // Current component instance
$vm.someData     // Access data
$vm.someMethod() // Call method
```

---

## Error Handling Patterns

### Try-Catch with Context
```typescript
async function fetchUser(id: string) {
  try {
    const response = await api.get(`/users/${id}`)
    return response.data
  } catch (error) {
    // Add context before re-throwing
    if (error instanceof ApiError) {
      throw new Error(`Failed to fetch user ${id}: ${error.message}`)
    }
    throw error
  }
}
```

### Error Boundaries (Vue)
```vue
<script setup lang="ts">
import { onErrorCaptured, ref } from 'vue'

const error = ref<Error | null>(null)

onErrorCaptured((err) => {
  error.value = err
  console.error('Captured error:', err)
  return false // Prevent propagation
})
</script>

<template>
  <div v-if="error" class="error">
    Something went wrong: {{ error.message }}
  </div>
  <slot v-else />
</template>
```

### Global Error Handler
```typescript
// Vue 3
app.config.errorHandler = (err, instance, info) => {
  console.error('Global error:', err)
  console.error('Component:', instance)
  console.error('Info:', info)
  // Send to error tracking service
}

// Window level
window.onerror = (message, source, lineno, colno, error) => {
  console.error('Uncaught error:', { message, source, lineno, colno, error })
}

window.onunhandledrejection = (event) => {
  console.error('Unhandled promise rejection:', event.reason)
}
```

---

## Network Debugging

### Request Inspection
```typescript
// Interceptor for logging
axios.interceptors.request.use((config) => {
  console.log('Request:', config.method?.toUpperCase(), config.url)
  console.log('Headers:', config.headers)
  console.log('Data:', config.data)
  return config
})

axios.interceptors.response.use(
  (response) => {
    console.log('Response:', response.status, response.config.url)
    return response
  },
  (error) => {
    console.error('Request failed:', error.config?.url, error.response?.status)
    return Promise.reject(error)
  }
)
```

### Mock Responses
```typescript
// For debugging without backend
if (import.meta.env.DEV) {
  const mockData = { users: [{ id: 1, name: "Test" }] }
  
  // Override fetch
  const originalFetch = window.fetch
  window.fetch = async (url, options) => {
    if (url.includes('/api/users')) {
      return new Response(JSON.stringify(mockData.users))
    }
    return originalFetch(url, options)
  }
}
```

---

## State Debugging

### Reactive State Logging
```typescript
// Vue - watch for changes
import { watch } from 'vue'

watch(
  () => store.user,
  (newValue, oldValue) => {
    console.log('User changed:', { from: oldValue, to: newValue })
  },
  { deep: true }
)

// Log all state changes
watch(
  () => ({ ...store.$state }),
  (state) => console.log('Store state:', state),
  { deep: true }
)
```

### State Snapshots
```typescript
function debugState<T>(label: string, state: T): T {
  console.log(`[${label}]`, JSON.parse(JSON.stringify(state)))
  return state
}

// Usage
const users = debugState('before filter', allUsers)
  .filter(u => u.active)
const result = debugState('after filter', users)
```

---

## Async Debugging

### Promise Chain Debugging
```typescript
fetchData()
  .then(data => {
    console.log('Step 1:', data)
    return processData(data)
  })
  .then(processed => {
    console.log('Step 2:', processed)
    return saveData(processed)
  })
  .catch(error => {
    console.error('Failed at step:', error)
  })
```

### Async/Await Debugging
```typescript
async function complexFlow() {
  console.log('Starting flow')
  
  const step1 = await fetchData()
  console.log('After fetch:', step1)
  
  const step2 = await processData(step1)
  console.log('After process:', step2)
  
  const step3 = await saveData(step2)
  console.log('After save:', step3)
  
  return step3
}
```

### Race Condition Detection
```typescript
let requestId = 0

async function fetchWithDebug(url: string) {
  const thisRequest = ++requestId
  console.log(`[${thisRequest}] Starting:`, url)
  
  const result = await fetch(url)
  
  console.log(`[${thisRequest}] Completed:`, url)
  if (thisRequest !== requestId) {
    console.warn(`[${thisRequest}] Stale request (current: ${requestId})`)
  }
  
  return result
}
```

---

## Performance Debugging

### Measure Execution Time
```typescript
function measureTime<T>(label: string, fn: () => T): T {
  const start = performance.now()
  const result = fn()
  const end = performance.now()
  console.log(`${label}: ${(end - start).toFixed(2)}ms`)
  return result
}

// Async version
async function measureTimeAsync<T>(label: string, fn: () => Promise<T>): Promise<T> {
  const start = performance.now()
  const result = await fn()
  const end = performance.now()
  console.log(`${label}: ${(end - start).toFixed(2)}ms`)
  return result
}

// Usage
const data = await measureTimeAsync('Fetch users', () => fetchUsers())
```

### Render Performance
```typescript
// Vue - track renders
import { onRenderTracked, onRenderTriggered } from 'vue'

onRenderTracked((e) => {
  console.log('Render tracked:', e.key, e.type)
})

onRenderTriggered((e) => {
  console.log('Render triggered:', e.key, e.type, e.newValue)
})
```

### Memory Leak Detection
```typescript
// Track object creation
const registry = new FinalizationRegistry((id) => {
  console.log(`Object ${id} was garbage collected`)
})

function createTrackedObject(id: string) {
  const obj = { data: new Array(10000) }
  registry.register(obj, id)
  return obj
}
```

---

## Common Debug Scenarios

### "Why isn't this updating?"
```typescript
// 1. Check if value actually changed
console.log('Before:', JSON.stringify(state))
mutateState()
console.log('After:', JSON.stringify(state))

// 2. Check reactivity (Vue)
import { isRef, isReactive, isProxy } from 'vue'
console.log('Is reactive?', isReactive(state))

// 3. Check if watcher is running
watch(state, () => console.log('Watcher fired!'))
```

### "Where is this being called from?"
```typescript
function mysteryFunction() {
  console.trace('Called from:')
  // or
  console.log(new Error().stack)
}
```

### "What's the actual type?"
```typescript
function debugType(value: unknown) {
  console.log({
    typeof: typeof value,
    constructor: value?.constructor?.name,
    isArray: Array.isArray(value),
    isNull: value === null,
    isUndefined: value === undefined,
    value,
  })
}
```

### "Why is this re-rendering?"
```typescript
// Vue - log dependency changes
const debugComputed = computed(() => {
  console.log('Computing...', { dep1: dep1.value, dep2: dep2.value })
  return dep1.value + dep2.value
})
```

---

## Avoid

- Leaving `console.log` in production code
- Using `debugger` in committed code
- Ignoring error stack traces
- Not using browser DevTools
- Debugging in production (use staging)
- Random `console.log` without context
- Not cleaning up debug code
