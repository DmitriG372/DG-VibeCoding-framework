# Vue to React Migration Skill

> Patterns for migrating Vue 3 (Composition API) to React 18+ with TypeScript.

---

## Component Structure Mapping

### Vue SFC → React FC

```vue
<!-- Vue 3 -->
<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'

const props = defineProps<{ title: string }>()
const emit = defineEmits<{ update: [value: string] }>()

const count = ref(0)
const doubled = computed(() => count.value * 2)

onMounted(() => console.log('mounted'))
</script>

<template>
  <div>{{ title }}: {{ doubled }}</div>
</template>
```

```tsx
// React 18
import { useState, useMemo, useEffect } from 'react'

interface Props {
  title: string
  onUpdate?: (value: string) => void
}

export function MyComponent({ title, onUpdate }: Props) {
  const [count, setCount] = useState(0)
  const doubled = useMemo(() => count * 2, [count])

  useEffect(() => {
    console.log('mounted')
  }, [])

  return <div>{title}: {doubled}</div>
}
```

---

## Reactivity Mapping

| Vue 3 | React 18 | Notes |
|-------|----------|-------|
| `ref(value)` | `useState(value)` | Returns `[value, setValue]` |
| `reactive({})` | `useState({})` | Or use multiple `useState` |
| `computed(() => x)` | `useMemo(() => x, [deps])` | Must specify dependencies |
| `watch(source, cb)` | `useEffect(() => cb(), [deps])` | Runs on change |
| `watchEffect(cb)` | `useEffect(cb)` | Auto-track not available |
| `onMounted(cb)` | `useEffect(cb, [])` | Empty deps = mount only |
| `onUnmounted(cb)` | `useEffect(() => () => cb(), [])` | Return cleanup fn |

---

## Props & Events

### Props

```vue
<!-- Vue -->
<script setup lang="ts">
const props = withDefaults(defineProps<{
  name: string
  count?: number
  variant?: 'primary' | 'secondary'
}>(), {
  count: 0,
  variant: 'primary'
})
</script>
```

```tsx
// React
interface Props {
  name: string
  count?: number
  variant?: 'primary' | 'secondary'
}

export function Component({
  name,
  count = 0,
  variant = 'primary'
}: Props) {
  // ...
}
```

### Events (Emits → Callbacks)

```vue
<!-- Vue -->
<script setup lang="ts">
const emit = defineEmits<{
  update: [value: string]
  delete: [id: string]
}>()

function handleSave() {
  emit('update', 'new value')
}
</script>
```

```tsx
// React
interface Props {
  onUpdate?: (value: string) => void
  onDelete?: (id: string) => void
}

export function Component({ onUpdate, onDelete }: Props) {
  function handleSave() {
    onUpdate?.('new value')
  }
}
```

---

## v-model Migration

### Single v-model

```vue
<!-- Vue Parent -->
<SearchInput v-model="query" />

<!-- Vue Child -->
<script setup lang="ts">
const model = defineModel<string>()
</script>
<template>
  <input :value="model" @input="model = $event.target.value" />
</template>
```

```tsx
// React Parent
<SearchInput value={query} onChange={setQuery} />

// React Child
interface Props {
  value: string
  onChange: (value: string) => void
}

export function SearchInput({ value, onChange }: Props) {
  return (
    <input
      value={value}
      onChange={(e) => onChange(e.target.value)}
    />
  )
}
```

### Multiple v-model

```vue
<!-- Vue -->
<DateRange v-model:start="startDate" v-model:end="endDate" />
```

```tsx
// React
<DateRange
  start={startDate}
  end={endDate}
  onStartChange={setStartDate}
  onEndChange={setEndDate}
/>
```

---

## Template Directives

### v-if / v-else

```vue
<!-- Vue -->
<template>
  <div v-if="isLoading">Loading...</div>
  <div v-else-if="error">Error: {{ error }}</div>
  <div v-else>{{ data }}</div>
</template>
```

```tsx
// React
return (
  <>
    {isLoading ? (
      <div>Loading...</div>
    ) : error ? (
      <div>Error: {error}</div>
    ) : (
      <div>{data}</div>
    )}
  </>
)

// Or with early returns
if (isLoading) return <div>Loading...</div>
if (error) return <div>Error: {error}</div>
return <div>{data}</div>
```

### v-for

```vue
<!-- Vue -->
<template>
  <ul>
    <li v-for="item in items" :key="item.id">
      {{ item.name }}
    </li>
  </ul>
</template>
```

```tsx
// React
return (
  <ul>
    {items.map(item => (
      <li key={item.id}>{item.name}</li>
    ))}
  </ul>
)
```

### v-show

```vue
<!-- Vue -->
<div v-show="isVisible">Content</div>
```

```tsx
// React
<div style={{ display: isVisible ? 'block' : 'none' }}>Content</div>

// Or with CSS class
<div className={isVisible ? '' : 'hidden'}>Content</div>
```

### v-bind (dynamic attributes)

```vue
<!-- Vue -->
<img :src="imageUrl" :alt="altText" />
<div :class="{ active: isActive, disabled: isDisabled }">
<button :disabled="isLoading">
```

```tsx
// React
<img src={imageUrl} alt={altText} />
<div className={`${isActive ? 'active' : ''} ${isDisabled ? 'disabled' : ''}`}>
// Or with clsx/classnames library
<div className={clsx({ active: isActive, disabled: isDisabled })}>
<button disabled={isLoading}>
```

### v-on (events)

```vue
<!-- Vue -->
<button @click="handleClick">
<input @input="handleInput" @keyup.enter="handleEnter">
<form @submit.prevent="handleSubmit">
```

```tsx
// React
<button onClick={handleClick}>
<input
  onChange={(e) => handleInput(e.target.value)}
  onKeyUp={(e) => e.key === 'Enter' && handleEnter()}
/>
<form onSubmit={(e) => { e.preventDefault(); handleSubmit(); }}>
```

---

## Composables → Custom Hooks

### Basic Pattern

```typescript
// Vue composable
export function useCounter(initial = 0) {
  const count = ref(initial)
  const increment = () => count.value++
  const decrement = () => count.value--
  return { count, increment, decrement }
}
```

```typescript
// React hook
export function useCounter(initial = 0) {
  const [count, setCount] = useState(initial)
  const increment = () => setCount(c => c + 1)
  const decrement = () => setCount(c => c - 1)
  return { count, increment, decrement }
}
```

### Async Data Fetching

```typescript
// Vue composable
export function useProjects() {
  const projects = ref<Project[]>([])
  const isLoading = ref(false)
  const error = ref<string | null>(null)

  async function fetch() {
    isLoading.value = true
    try {
      const { data } = await supabase.from('projects').select('*')
      projects.value = data ?? []
    } catch (e) {
      error.value = e.message
    } finally {
      isLoading.value = false
    }
  }

  return { projects, isLoading, error, fetch }
}
```

```typescript
// React hook
export function useProjects() {
  const [projects, setProjects] = useState<Project[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const fetch = useCallback(async () => {
    setIsLoading(true)
    setError(null)
    try {
      const { data } = await supabase.from('projects').select('*')
      setProjects(data ?? [])
    } catch (e) {
      setError(e instanceof Error ? e.message : 'Unknown error')
    } finally {
      setIsLoading(false)
    }
  }, [])

  return { projects, isLoading, error, fetch }
}
```

### Cleanup Pattern

```typescript
// Vue
export function useSubscription(onUpdate: Function) {
  const channel = supabase.channel('changes').on(...).subscribe()

  onUnmounted(() => {
    supabase.removeChannel(channel)
  })
}
```

```typescript
// React
export function useSubscription(onUpdate: Function) {
  useEffect(() => {
    const channel = supabase.channel('changes').on(...).subscribe()

    return () => {
      supabase.removeChannel(channel)
    }
  }, [onUpdate])
}
```

---

## State Management

### Pinia → Zustand

```typescript
// Vue + Pinia
export const useProjectStore = defineStore('projects', () => {
  const projects = ref<Project[]>([])
  const currentId = ref<string | null>(null)

  const current = computed(() =>
    projects.value.find(p => p.id === currentId.value)
  )

  async function fetch() {
    const { data } = await supabase.from('projects').select('*')
    projects.value = data ?? []
  }

  return { projects, currentId, current, fetch }
})

// Usage
const store = useProjectStore()
const { projects } = storeToRefs(store)
store.fetch()
```

```typescript
// React + Zustand
import { create } from 'zustand'

interface ProjectStore {
  projects: Project[]
  currentId: string | null
  current: () => Project | undefined
  fetch: () => Promise<void>
  setCurrentId: (id: string | null) => void
}

export const useProjectStore = create<ProjectStore>((set, get) => ({
  projects: [],
  currentId: null,

  current: () => get().projects.find(p => p.id === get().currentId),

  fetch: async () => {
    const { data } = await supabase.from('projects').select('*')
    set({ projects: data ?? [] })
  },

  setCurrentId: (id) => set({ currentId: id })
}))

// Usage
const projects = useProjectStore(state => state.projects)
const fetch = useProjectStore(state => state.fetch)
useEffect(() => { fetch() }, [fetch])
```

### Pinia → Redux Toolkit

```typescript
// React + Redux Toolkit
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit'

export const fetchProjects = createAsyncThunk(
  'projects/fetch',
  async () => {
    const { data } = await supabase.from('projects').select('*')
    return data ?? []
  }
)

const projectsSlice = createSlice({
  name: 'projects',
  initialState: {
    items: [] as Project[],
    currentId: null as string | null,
    status: 'idle' as 'idle' | 'loading' | 'succeeded' | 'failed'
  },
  reducers: {
    setCurrentId: (state, action) => {
      state.currentId = action.payload
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchProjects.pending, (state) => {
        state.status = 'loading'
      })
      .addCase(fetchProjects.fulfilled, (state, action) => {
        state.status = 'succeeded'
        state.items = action.payload
      })
  }
})
```

---

## Router Migration

### Vue Router → React Router

```typescript
// Vue Router
const routes = [
  { path: '/', component: () => import('@/views/Home.vue') },
  { path: '/projects/:id', component: () => import('@/views/Project.vue'), props: true },
  { path: '/:pathMatch(.*)*', component: NotFound }
]

// In component
const route = useRoute()
const router = useRouter()
const id = route.params.id
router.push('/projects/123')
```

```tsx
// React Router
import { BrowserRouter, Routes, Route, useParams, useNavigate } from 'react-router-dom'

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/projects/:id" element={<Project />} />
        <Route path="*" element={<NotFound />} />
      </Routes>
    </BrowserRouter>
  )
}

// In component
function Project() {
  const { id } = useParams<{ id: string }>()
  const navigate = useNavigate()

  const goHome = () => navigate('/')
}
```

---

## Slots → Children & Render Props

### Default Slot

```vue
<!-- Vue -->
<Card>
  <p>Card content</p>
</Card>

<!-- Card.vue -->
<template>
  <div class="card">
    <slot />
  </div>
</template>
```

```tsx
// React
<Card>
  <p>Card content</p>
</Card>

// Card.tsx
interface Props {
  children: React.ReactNode
}

export function Card({ children }: Props) {
  return <div className="card">{children}</div>
}
```

### Named Slots

```vue
<!-- Vue -->
<Card>
  <template #header>Title</template>
  <template #default>Content</template>
  <template #footer>Footer</template>
</Card>

<!-- Card.vue -->
<template>
  <div class="card">
    <header><slot name="header" /></header>
    <main><slot /></main>
    <footer><slot name="footer" /></footer>
  </div>
</template>
```

```tsx
// React
<Card
  header={<span>Title</span>}
  footer={<span>Footer</span>}
>
  Content
</Card>

// Card.tsx
interface Props {
  header?: React.ReactNode
  footer?: React.ReactNode
  children: React.ReactNode
}

export function Card({ header, footer, children }: Props) {
  return (
    <div className="card">
      {header && <header>{header}</header>}
      <main>{children}</main>
      {footer && <footer>{footer}</footer>}
    </div>
  )
}
```

### Scoped Slots → Render Props

```vue
<!-- Vue -->
<DataList :items="users">
  <template #item="{ item, index }">
    <span>{{ index }}: {{ item.name }}</span>
  </template>
</DataList>
```

```tsx
// React
<DataList
  items={users}
  renderItem={(item, index) => (
    <span>{index}: {item.name}</span>
  )}
/>

// DataList.tsx
interface Props<T> {
  items: T[]
  renderItem: (item: T, index: number) => React.ReactNode
}

export function DataList<T>({ items, renderItem }: Props<T>) {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{renderItem(item, index)}</li>
      ))}
    </ul>
  )
}
```

---

## Provide/Inject → Context

```typescript
// Vue
// Parent
const theme = ref('light')
provide('theme', theme)

// Child
const theme = inject('theme')
```

```tsx
// React
// Create context
const ThemeContext = createContext<string>('light')

// Parent
function App() {
  const [theme, setTheme] = useState('light')
  return (
    <ThemeContext.Provider value={theme}>
      <Child />
    </ThemeContext.Provider>
  )
}

// Child
function Child() {
  const theme = useContext(ThemeContext)
}
```

---

## Refs (Template Refs → useRef)

```vue
<!-- Vue -->
<script setup lang="ts">
const inputRef = ref<HTMLInputElement>()

function focus() {
  inputRef.value?.focus()
}
</script>

<template>
  <input ref="inputRef" />
</template>
```

```tsx
// React
function Component() {
  const inputRef = useRef<HTMLInputElement>(null)

  function focus() {
    inputRef.current?.focus()
  }

  return <input ref={inputRef} />
}
```

---

## Migration Checklist

### Per Component
- [ ] Convert `<script setup>` to function component
- [ ] Convert `ref()` to `useState()`
- [ ] Convert `computed()` to `useMemo()`
- [ ] Convert `watch/watchEffect` to `useEffect()`
- [ ] Convert emits to callback props
- [ ] Convert v-model to value/onChange props
- [ ] Convert template directives (v-if, v-for, v-show)
- [ ] Convert slots to children/props
- [ ] Convert scoped CSS to CSS modules or styled-components

### Per Project
- [ ] Set up React project with Vite
- [ ] Install dependencies (react-router, zustand/redux)
- [ ] Migrate composables to custom hooks
- [ ] Migrate Pinia stores to Zustand/Redux
- [ ] Migrate Vue Router to React Router
- [ ] Update tests (Vue Testing Library → React Testing Library)

---

## Common Pitfalls

### 1. Missing Dependencies in useEffect
```tsx
// ❌ Wrong - stale closure
useEffect(() => {
  fetchData(userId)
}, []) // Missing userId

// ✅ Correct
useEffect(() => {
  fetchData(userId)
}, [userId])
```

### 2. Direct State Mutation
```tsx
// ❌ Wrong
const [items, setItems] = useState([])
items.push(newItem) // Mutation!

// ✅ Correct
setItems([...items, newItem])
```

### 3. Object/Array in Dependencies
```tsx
// ❌ Wrong - new object every render
useEffect(() => {}, [{ id: 1 }])

// ✅ Correct - use primitive or useMemo
const config = useMemo(() => ({ id: 1 }), [])
useEffect(() => {}, [config])
```

---

## Avoid

- Converting Options API patterns (convert to hooks instead)
- Keeping Vue's `.value` syntax in React
- Using `reactive()` patterns (use individual `useState` calls)
- Forgetting cleanup in useEffect
- Over-using Context (prop drilling is often fine)
- Not memoizing expensive computations
