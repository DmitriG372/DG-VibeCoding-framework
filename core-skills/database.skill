# Database Skill

> Patterns for database work, queries, schema design.

**See also:**
- `framework-philosophy.skill` for migration-first development principle
- `supabase-migrations.skill` for detailed migration workflows

---

## Migration-First Development

> ALWAYS use migration system. Never manual SQL in production.

### Principle
Every schema change goes through a migration file:
1. Create migration → `supabase migration new feature_x`
2. Write SQL → CREATE/ALTER statements
3. Test locally → `supabase db reset`
4. Deploy → `supabase db push`

See `supabase-migrations.skill` for detailed workflow.

---

## Schema Design

### Naming Conventions
- Tables: `snake_case`, plural (`users`, `project_tasks`)
- Columns: `snake_case` (`created_at`, `user_id`)
- Foreign keys: `[table]_id` (`user_id`, `project_id`)
- Indexes: `idx_[table]_[column]`

### Essential Columns
```sql
CREATE TABLE example (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  -- ... your columns ...
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

### Soft Delete Pattern
```sql
deleted_at TIMESTAMPTZ DEFAULT NULL

-- Query active records
SELECT * FROM users WHERE deleted_at IS NULL;
```

---

## Query Patterns

### Pagination
```sql
SELECT * FROM items
ORDER BY created_at DESC
LIMIT $1 OFFSET $2;

-- Better: Cursor-based
SELECT * FROM items
WHERE created_at < $cursor
ORDER BY created_at DESC
LIMIT $1;
```

### Search
```sql
-- Simple ILIKE
WHERE name ILIKE '%' || $1 || '%'

-- Full-text (PostgreSQL)
WHERE to_tsvector('english', name) @@ plainto_tsquery('english', $1)
```

### Upsert
```sql
INSERT INTO items (id, name, value)
VALUES ($1, $2, $3)
ON CONFLICT (id) DO UPDATE SET
  name = EXCLUDED.name,
  value = EXCLUDED.value,
  updated_at = NOW();
```

---

## Performance

### Index Strategy
```sql
-- Single column (most queries)
CREATE INDEX idx_users_email ON users(email);

-- Composite (multi-column WHERE)
CREATE INDEX idx_tasks_user_status ON tasks(user_id, status);

-- Partial (filtered queries)
CREATE INDEX idx_active_users ON users(email) WHERE deleted_at IS NULL;
```

### Query Optimization
- Use `EXPLAIN ANALYZE` before optimizing
- Avoid `SELECT *` — list columns
- Use prepared statements
- Batch inserts when possible

---

## Supabase Specifics

### RLS (Row Level Security)
```sql
-- Enable RLS
ALTER TABLE items ENABLE ROW LEVEL SECURITY;

-- Policy: users see own data
CREATE POLICY "Users see own items" ON items
  FOR SELECT USING (auth.uid() = user_id);

-- Policy: users modify own data
CREATE POLICY "Users modify own items" ON items
  FOR ALL USING (auth.uid() = user_id);
```

### Realtime
```typescript
const channel = supabase
  .channel('changes')
  .on('postgres_changes', { event: '*', schema: 'public', table: 'items' },
    (payload) => console.log(payload))
  .subscribe();
```

---

## Migrations (CRITICAL!)

> Without migrations = no production deployment control

### Setup Supabase CLI
```bash
# Install
npm install -g supabase

# Init in project
supabase init

# Link to existing project
supabase link --project-ref <your-project-ref>

# Pull current schema (first time)
supabase db pull
```

### Project Structure
```
/supabase/
├── config.toml              # Supabase config
├── migrations/              # Schema changes (append-only!)
│   ├── 20251101000000_initial_schema.sql
│   ├── 20251115000000_add_timer_recovery.sql
│   └── 20251118000000_add_baseline_tags.sql
└── seed.sql                 # Initial/test data
```

### Create Migration
```bash
# Create new migration file
supabase migration new add_feature_x

# Creates: supabase/migrations/20251124120000_add_feature_x.sql
```

### Migration File Template
```sql
-- Migration: add_feature_x
-- Description: [What this migration does]

-- ============================================
-- UP: Apply changes
-- ============================================

CREATE TABLE feature_x (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable RLS
ALTER TABLE feature_x ENABLE ROW LEVEL SECURITY;

-- Policies
CREATE POLICY "Users see own feature_x" ON feature_x
  FOR SELECT USING (auth.uid() = user_id);

-- ============================================
-- DOWN: Rollback (keep commented, for reference)
-- ============================================
-- DROP POLICY IF EXISTS "Users see own feature_x" ON feature_x;
-- DROP TABLE IF EXISTS feature_x;
```

### Apply Migrations
```bash
# Push to remote (staging/production)
supabase db push

# Reset local (drops all, re-runs migrations + seed)
supabase db reset

# Check migration status
supabase migration list
```

### Migration Workflow
```
1. Create migration locally    → supabase migration new xyz
2. Write SQL                   → edit the .sql file
3. Test locally (optional)     → supabase db reset
4. Push to staging             → supabase db push (linked to staging)
5. Test on staging
6. Push to production          → supabase db push (linked to prod)
7. Commit to git               → migrations are version controlled!
```

### Rules (CRITICAL!)
- **Append-only** — Never edit existing migrations
- **Transactions** — Supabase wraps each migration in transaction
- **Naming** — Timestamp prefix auto-generated, add descriptive suffix
- **Idempotent** — Use `IF NOT EXISTS`, `IF EXISTS` where possible
- **Test first** — Always test on staging before production

### Pre-production Checklist
```
[ ] All migrations in git
[ ] Migrations tested on staging
[ ] Seed data prepared
[ ] RLS policies verified
[ ] Indexes added for queries
[ ] Final schema documented
```

---

## Seeds (Optional)

> Initial data and test data management. Use as needed — not every project requires seeds.

### Seed File Location
```
/supabase/seed.sql
```

### Seed Structure
```sql
-- ============================================
-- CORE DATA (always needed)
-- ============================================

-- Roles
INSERT INTO roles (id, name) VALUES
  ('admin', 'Administrator'),
  ('user', 'Regular User')
ON CONFLICT (id) DO NOTHING;

-- Default settings
INSERT INTO settings (key, value) VALUES
  ('app_name', 'MyApp'),
  ('version', '1.0.0')
ON CONFLICT (key) DO NOTHING;

-- ============================================
-- TEST DATA (development only)
-- ============================================

-- Only insert if in development
DO $$
BEGIN
  -- Test users (use real UUIDs from Supabase Auth for testing)
  INSERT INTO profiles (id, email, name)
  VALUES
    ('test-uuid-1', 'test@example.com', 'Test User'),
    ('test-uuid-2', 'demo@example.com', 'Demo User')
  ON CONFLICT (id) DO NOTHING;
END $$;
```

### Run Seeds
```bash
# Seeds run automatically after migrations on reset
supabase db reset

# Run seed manually (if needed)
psql -h localhost -p 54322 -U postgres -d postgres -f supabase/seed.sql
```

### Seed Categories

| Category | When | Example |
|----------|------|---------|
| **Core** | Always | Roles, permissions, default settings |
| **Reference** | Always | Countries, categories, statuses |
| **Test** | Dev only | Test users, sample data |
| **Demo** | Demo env | Realistic demo content |

---

## Avoid

- N+1 queries — use JOINs or batch fetching
- Missing indexes on foreign keys
- Storing JSON when relations work better
- Over-indexing — indexes slow writes
- Raw SQL in user-facing code — use parameterized queries

---

## Supabase Auth Integration

### Get Current User
```typescript
// In component/composable
const { data: { user } } = await supabase.auth.getUser()

// Listen to auth changes
supabase.auth.onAuthStateChange((event, session) => {
  if (event === 'SIGNED_IN') {
    // Handle sign in
  }
})
```

### Auth + RLS Pattern
```sql
-- Table with user ownership
CREATE TABLE user_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) NOT NULL DEFAULT auth.uid(),
  -- ... columns
);

-- Auto-set user_id on insert
CREATE POLICY "Auto user_id" ON user_items
  FOR INSERT WITH CHECK (user_id = auth.uid());
```

### Protected API Routes (Edge Functions)
```typescript
// Verify JWT in Edge Function
const authHeader = req.headers.get('Authorization')
const { data: { user }, error } = await supabase.auth.getUser(
  authHeader?.replace('Bearer ', '')
)
if (error || !user) {
  return new Response('Unauthorized', { status: 401 })
}
```

---

## Supabase Edge Functions

### Create Function
```bash
supabase functions new my-function
```

### Function Structure
```
/supabase/functions/
├── my-function/
│   └── index.ts
└── _shared/           # Shared utilities
    └── cors.ts
```

### Basic Edge Function
```typescript
// supabase/functions/my-function/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, content-type',
}

serve(async (req) => {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!  // Server-side, bypasses RLS
    )

    const { data, error } = await supabase.from('items').select('*')
    
    return new Response(
      JSON.stringify({ data }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )
  } catch (err) {
    return new Response(
      JSON.stringify({ error: err.message }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )
  }
})
```

### Deploy Functions
```bash
# Deploy single function
supabase functions deploy my-function

# Deploy all functions
supabase functions deploy

# Set secrets
supabase secrets set MY_SECRET=value
```

### Call from Client
```typescript
const { data, error } = await supabase.functions.invoke('my-function', {
  body: { param: 'value' }
})
```

---

## Supabase Storage

### Bucket Setup
```sql
-- Create bucket (via SQL or Dashboard)
INSERT INTO storage.buckets (id, name, public)
VALUES ('avatars', 'avatars', true);

-- Storage RLS policy
CREATE POLICY "Users upload own avatar" ON storage.objects
  FOR INSERT WITH CHECK (
    bucket_id = 'avatars' AND
    auth.uid()::text = (storage.foldername(name))[1]
  );
```

### Upload File
```typescript
const file = event.target.files[0]
const filePath = `${user.id}/${file.name}`

const { data, error } = await supabase.storage
  .from('avatars')
  .upload(filePath, file, {
    cacheControl: '3600',
    upsert: true
  })
```

### Get Public URL
```typescript
const { data } = supabase.storage
  .from('avatars')
  .getPublicUrl('user-id/avatar.png')

// data.publicUrl
```

---

## TypeScript Types Generation

### Generate Types from Schema
```bash
# Generate types
supabase gen types typescript --project-id <ref> > src/types/database.types.ts

# Or from local
supabase gen types typescript --local > src/types/database.types.ts
```

### Use Generated Types
```typescript
import { Database } from '@/types/database.types'

type Tables = Database['public']['Tables']
type Project = Tables['projects']['Row']
type ProjectInsert = Tables['projects']['Insert']
type ProjectUpdate = Tables['projects']['Update']

// Typed Supabase client
import { createClient } from '@supabase/supabase-js'

const supabase = createClient<Database>(url, key)

// Now fully typed!
const { data } = await supabase
  .from('projects')
  .select('*')  // data is Project[]
```

### Auto-regenerate (package.json)
```json
{
  "scripts": {
    "db:types": "supabase gen types typescript --project-id $PROJECT_REF > src/types/database.types.ts"
  }
}
```

---

## Database Functions & Triggers

### Auto-update updated_at
```sql
-- Function
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$ LANGUAGE plpgsql;

-- Apply to table
CREATE TRIGGER set_updated_at
  BEFORE UPDATE ON my_table
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at();
```

### Audit Log Trigger
```sql
CREATE TABLE audit_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  table_name TEXT NOT NULL,
  record_id UUID NOT NULL,
  action TEXT NOT NULL,
  old_data JSONB,
  new_data JSONB,
  user_id UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE OR REPLACE FUNCTION audit_changes()
RETURNS TRIGGER AS $
BEGIN
  INSERT INTO audit_log (table_name, record_id, action, old_data, new_data, user_id)
  VALUES (
    TG_TABLE_NAME,
    COALESCE(NEW.id, OLD.id),
    TG_OP,
    CASE WHEN TG_OP = 'DELETE' THEN to_jsonb(OLD) ELSE NULL END,
    CASE WHEN TG_OP != 'DELETE' THEN to_jsonb(NEW) ELSE NULL END,
    auth.uid()
  );
  RETURN COALESCE(NEW, OLD);
END;
$ LANGUAGE plpgsql SECURITY DEFINER;
```
